1. **哈希表**
    + [基本概念](https://plushunter.github.io/2017/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/)
    + [哈希表](http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html)
    + [C++实现hash map](https://cloud.tencent.com/developer/article/1010478)
2. **C++**
    + [C++ 参考手册](https://zh.cppreference.com/w/cpp)
    + [STL常用函数总结](https://www.cnblogs.com/linuxAndMcu/category/1381526.html)
3. 面试问题
    + [拷贝构造函数的参数为什么必须使用引用类型](https://blog.csdn.net/tunsanty/article/details/4264738)
    + [虚函数和纯虚函数的区别](https://blog.csdn.net/Hackbuteer1/article/details/7558868)
    + [Item 36：不要重写继承来的非虚函数](https://blog.csdn.net/yangjvn/article/details/48782601)
    + [C++ 封装、继承、多态、重载、覆盖、隐藏基本概念详解](https://blog.csdn.net/ManagerUser/article/details/75208158)
    + [C++ 之 多态（非常非常重要，重点在后面）](https://blog.csdn.net/qq_39412582/article/details/81628254)
    + [C++ 多态详解](https://www.cnblogs.com/dormant/p/5223215.html)
    + [浅谈C++中指针和引用的区别](https://www.cnblogs.com/dolphin0520/archive/2011/04/03/2004869.html)
    + [友元函数和友元类](https://blog.csdn.net/jackystudio/article/details/11799777)
    + [C/C++中Static和Const的作用](https://blog.csdn.net/guyuealian/article/details/53118850)
    + [C和C++的区别](http://www.k6k4.com/simple_question/qshow/aaqtotpmw1537796355161)
    + [C++文件编译与执行的四个阶段](http://www.k6k4.com/simple_question/qshow/aaqjjviar1537799714129)
    + [C/C++程序编译过程详解](https://www.cnblogs.com/mickole/articles/3659112.html)
    + [深拷贝和浅拷贝的区别](http://www.k6k4.com/simple_question/qshow/aaqjjxlby1537800183617)
    + [C++中基类的析构函数为什么要用virtual虚析构函数](https://blog.csdn.net/iicy266/article/details/11906457)
    + [基类的析构函数为什么要用virtual虚析构函数](http://www.k6k4.com/simple_question/qshow/aaqtbepkm1538099105453)
    + [C++析构函数为什么要为虚函数](https://www.cnblogs.com/zsq1993/p/5947671.html)
    + [哪些成员函数不能被继承](http://www.k6k4.com/simple_question/qshow/aaqcgzgcl1537799336958)
    + [关键字static有什么作用](http://www.k6k4.com/simple_question/qshow/aaqoluiwy1538097538950)
    + [C++中delete和delete[]的区别](https://www.cnblogs.com/charley_yang/archive/2010/12/08/1899982.html)
    + [delete 和 delete []的真正区别](https://www.cnblogs.com/wangjian8888/p/7905176.html)
    + [new 、 delete 、 malloc 、 free 关系](https://www.cnblogs.com/xumiao1314/p/7200539.html)
    + 简单介绍vector内存分配方式
        * 先申请一定的大小的数组, 当数组填满之后,另外申请一块原数组两倍大的新数组, 然后把原数组的数据拷贝到新数组, 最后释放原数组的大小
    + [C++ vector和list的区别](https://www.cnblogs.com/shijingjing07/p/5587719.html)
    + [C++继承：公有，私有，保护](https://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html)
    + [c++ 内联函数（一看就懂）](https://blog.csdn.net/BjarneCpp/article/details/76044493)
    + [C++---内联函数和宏函数的优缺点](https://blog.csdn.net/qq_37934101/article/details/81266548)
    + [C++中四种强制类型转换区别详解](https://www.cnblogs.com/cauchy007/p/4968707.html)
    + [C++四种类型之间的转换](https://www.cnblogs.com/Spider-spiders/p/8898585.html)
    + [C++中的四个智能指针](https://www.cnblogs.com/xiaobaizzz/p/12167393.html)
    + [C/C++野指针](https://www.cnblogs.com/418ks/p/10743902.html)
    + [c++ 函数指针](https://blog.csdn.net/zj1131190425/article/details/92065897)
    + [strcpy和strncpy用法和区别](https://www.cnblogs.com/xmxu/archive/2012/08/20/2647382.html)
    + [C++ 构造函数中调用虚函数](https://www.cnblogs.com/qiaoconglovelife/p/5337115.html)
    + [C++中构造函数能调用虚函数吗？（答案是语法可以，输出错误），但Java里居然可以](https://www.cnblogs.com/findumars/p/7123497.html)
    + [c++学习之容器——erase()函数](https://blog.csdn.net/qingtianweichong/article/details/9531919)
    + [c++ 中对关联容器和序列容器的 erase()方法](https://www.cnblogs.com/Hwangzhiyoung/p/8926984.html)
    + [fork详解](https://www.cnblogs.com/hellogiser/p/fork.html)
    + [linux中fork（）函数详解](https://www.cnblogs.com/dongguolei/p/8086346.html)
    + [STL标准库-容器-unordered_set](https://www.cnblogs.com/LearningTheLoad/p/7565694.html)
    + [C++ 异常](https://www.cnblogs.com/nzbbody/p/3418989.html)
    + [在linux环境下编译C++ 程序](https://www.cnblogs.com/ucas/p/5778664.html)
    + [为什么C++编译器不能支持对模板的分离式编译](https://blog.csdn.net/pongba/article/details/19130)
    + [关于C++模板分离式编译](https://blog.csdn.net/wk_bjut_edu_cn/article/details/85038035)
    + [动态链接和静态链接的区别](https://www.cnblogs.com/tracylee/archive/2012/10/15/2723816.html)
    + [C++高并发多线程学习(一)](https://blog.csdn.net/orange_littlegirl/article/details/102718884)
    + [事件驱动模型](https://www.cnblogs.com/bigberg/p/8028034.html)
    + [同步与异步，回调与协程](https://www.cnblogs.com/xybaby/p/6406191.html)
    + [怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473)
    + 3.1 C++ primer阅读笔记
        * 对象是指一块能存储数据并**具有某种类型**的**内存空间**。
        * **初始化不是赋值**，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
        * 未初始化的变量含有一个**不确定的值**，如果试图拷贝或者以其他形式访问此类值将引发错误，使用未初始化变量的值是一种错误的编程并且很难调试。定义在函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示的初始化，其值由类决定。
        * 为了支持**分离式编译**，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含那个名字的声明。而定义复制创建与名字关联的实体。变量声明规定了变量的类型和名字，在这一点上与定义相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。变量能且只能被定义一次，但是可以被多次声明。在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
        * C++是一种**静态语言**，其含义是在编译阶段检查类型。其中检查类型的过程是称为类型检查。
        * **复合类型**：基于其他类型定义的类型。如引用和指针。
        * 引用为**对象**起的另外一个名字，引用类型引用类外一种类型。引用即别名，。引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。因为引用本身不是一个对象，**所以不能定义引用的引用**。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，**因此引用必须把初始化**。
        * 指针是指向另外一种类型的复合类型。指针本身就是一个对象，允许对指针赋值和拷贝。而且指针在生命周期内它可以先后指向几个不同的对象。指针无需定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的初始值。
        * **空指针**不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。有三种方法可以生成空指针。分别用**0/NULL/nullptr**初始化为空指针。得到空指针的最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，可以被转换成任意其他的指针类型。
        * 引用本身不是一个对象，因此不能定义指向引用的指针。
        * const限定符，我们希望定义这种变量，它的值不能被改变。因为const对象一旦创建后其值就不能改变，所以const对象必须初始化。默认状态下，const对象仅在文件内有效。如果多个文件共享对象，则用extern关键字。
        * 常量表达式是指**值不会改变**且在**编译过程**就得到计算结果的表达式。
        * auto类型说明符：编程时常常需要把表达式的值赋给变量，这就需要在申明变量的时候清楚的知道表达式的类型。然而，做到这一点并非容易，有时甚至根本做不到，为了解决这个问题，C++11引入了auto类型说明符。用它就能让**编译器**替我们分析表达式所属的类型。
        * auto一般会忽略掉顶层const,同时底层const会保留下来。如果需要推断出const类型是一个顶层const,则需要明确指出const auto.
        * decltype类型指示符：希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引用了第二种类型说明符decltype,他的作用是选择并返回操作数的类型。
        * decltype处理顶层const和引用的方式和auto不同，返回变量的类型**包括顶层const和引用。**引用从来都是其所指对象的同义词出现，只有用在decltype处是一个例外。
        * 如果r是引用类型，则decltype(r)的结果是引用类型；如果r是指针类型，则decltype(*r)的结果也是是引用类型。则decltype((variable))(**注意是双括号**)的结果永远是引用类型。
        * C++中既**有类模板，也有函数模板**。模板本身不是类或函数，可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。
        * 数组也是一个对象，也可以定义数组的指针和引用。
        * 当一个对象被用作**右值**的时候，用的是右值的值(内容)；当对象被用作**左值**的时候，用的是对象的身份(在内存中的位置)。在需要右值的地方可以用左值来代替，但是不能把右值当成左值(也就是位置)使用。当一个左值被当成右值来使用时，实际上使用的是他的内容。
        * 复合表达式是指含有二个或多个运算符的表达式。
        * 有四种运算符明确规定了运算对象的求值顺序，逻辑与(&&)运算符，只有当左侧运算对象的值为真时，才继续求右侧运算对象的值。另外三种分别是逻辑或(||)，条件(?:)运算符和逗号(,)运算符。
        * 运算对象的**求值顺序**和**优先级**和**结合律**无关，在一条形如:f() + g() * f() + j()的表达式中：
            - 优先级规定先计算g()的返回值和f()的返回值相乘
            - 结合律规定f()的返回值先和g()*f()的结果相加，再和j()的返回值结果详相加
            - 对于这些函数的调用顺序并没有明确规定。
        * 点运算符获取对象的一个成员；箭头运算符和运算符相关，表达式ptr->mem等价于(*ptr).mem
        * 当数组被用作decltype关键字参数, 取地址符(&)，sizseof以及typeid时，数组的类型不会改变。
        * 复合语句是指用花括号括起来的语句和声明的序列，复合语句也**被称作块**。一个块就是一个作用域。
        * 函数的调用完成二项工作，一是实参初始化函数对应的形参，二是将调用权转移给被调用函数。return语句也完成二项工作，一是返回return语句中的值(如果有的话)，二是将控制权从被调用函数转移回主调函数。
        * 实参是形参是的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参和形参存在对应关系，**但是没有规定实参的求值顺序，编译器能以任意可行的顺序对实参求值**。
        * 函数的返回类型**不能是数组类型或函数类型**，但**可以是指向数组或函数的指针**。
        * 熟悉C语言的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替换指针。
        * 如果函数无须改变引用参数的值，最好将其申请为常量引用。
        * **把函数不会改变的形参定义成(普通的)引用是一种比较常见的错误**，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。就像刚刚看到的，我们不能把const对象，字面值或者需要类型转换的对象传递给普通的引用指针。
        * **数组的二个性质是**：不允许拷贝数组，以及使用数组时会将其转换成指针。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转化成指针，所以当我们传递一个数组时，实际上传递的是指向数组首元素的指针。因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。
        * 函数返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。
        * 函数重载：如果同一个作用域内的函数名字相同但形参列表不同，我们称之为函数的重载。
        * Main函数不能重载。
        * **类的接口**包括用户所能执行的操作。**类的实现**则包括类的数据成员，负责接口实现的函数以及定义类所需的各自私有函数。
        * 构造函数：每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。类的构造函数的任务式初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
        * 构造函数的名字和类名相同，没有返回类型，类可以包含多个构造函数，和其他重载函数差不多。
        * 默认构造函数在很方面都有其特殊性，其中之一就是，如果我们的类没有显式地定义构造函数，编译器就会为我们隐式地定义一个默认构造函数。
        * 对于一个普通的类来说，必须定义他自己的默认构造函数，原因有三：
            - 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
            - 对于某些类来说，编译器合成的默认构造函数可能执行错误的操作。如果定义在块中的内置类型和复合类型的对象被默认初始化，则他们的值是未定义的。该准则同样适用于默认初始化的内置类型成员。因此，含有内置类型或复合类型成员的类应该在类内初始化这些成员，或者定义一个自己默认的构造函数。否则，用户在创建你类的对象时，就可能得到未定义的值。
            - 编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员类型没有默认的构造函数，那么编译器则无法初始化该成员。
        * 使用class和struct定义类唯一的区别就是默认的访问权限。
        * 封装是指保护类的成员不被随意访问的能力。通过把类的实现细节设置成private，我们就能完成类的封装。封装实现了类的接口和实现的分离。
        * 封装有二个重要的有点：一是确保用户代码不会无意间破坏封装对象的状态。二是被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。
        * 类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数称为他的友元(friend)。
        * 定义在函数内部的函数时自动内联inline的。
        * 类可以把其他类定义成友元，也可以把其他类(之前已定义过的)的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。
        * 每个类负责控制自己的友元类或友元函数。
        * 如果类的成员式const，引用或者属于某种未提供默认构造函数的类类型，我们必须通过**构造函数初始值列表**为这些成员提供初始值。
        * 委托构造函数：一个委托构造函数使用它所属类的**其他构造函数**执行他自己的初始化过程，或者说他把他自己的(或者全部)职责委托给了其他构造函数。
        * 如果构造函数**只接受一个实参**，则它实际上定义了转换此类类型的隐式转换机制。有时我们把这种构造函数称作**转换构造函数**。
        * 类的静态成员：有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。类的静态成员存在于任何对象之外，对象不包含任何与静态成员有关的数据。类似的，静态成员函数不和任何对象绑定在一起，他们不包含this指针。
        * 我们可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义类的静态成员时，不能重复static关键字。该关键字只出现在类内部的声明语句中。
        * 类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，他将一直存在于程序的整个整个生命周期中。
        * 导致缓冲刷新(即，数据真正写到输出设备或文件)的原因很多：
            - 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。
            - 缓冲区满时，需要刷新缓冲，然后新的数据才能继续写入缓冲区。
            - 我们可以使用操作符如endl来显示刷新缓冲区。
            - 在每个输出操作之后，我们可以用操作符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。
            - 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到count，因此，读cin或写cerr都会导致cout的缓冲区被刷新。
        * 如果程序崩溃，输出缓冲区不会被刷新。
        * 一个容器就是一些特定类型对象的集合。
        * **顺序容器**：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖元素的值，而是与元素加入容器时的位置相对应。
        * 当一个容器**初始化为另一个容器的拷贝时**，二个容器的**容器类型**和**元素类型**都必须相同。
        * 除array外，swap不对任何元素进行拷贝、删除或者插入操作，因此可以保证在常数时间内完成。
        * 向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。
        * 将元素插入到vector、deque和string中的任何位置都是合法的，然而，这样做可能很耗时。
        * emplace函数直接在容器中构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。
        * 对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误。
        * 删除deque中除首尾位置之外的任何元素都会是所有的迭代器、引用和指针失效。指向vector和string中删除点之后位置的迭代器、引用和指针都会失效。
        * 向容器中**添加或者删除**元素的操作**可能**会使指向容器元素的指针、引用和迭代器失效。
        * **容器适配器**：一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。一个容器适配器接受了一种已有的容器类型，使其行为看起来像一种不同的类型。
        * stack<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。stack<T> 模板定义在头文件 stack 中。
        * queue<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。queue<T> 模板定义在头文件 queue 中。
        * priority_queue<T>：是一个封装了 vector<T> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。priority_queue<T> 模板定义在头文件 queue 中。
        * 标准库容器定义的操作惊人的小。标准库并未给每个容器添加大量的功能，而是提供了一组算法，这些算法中的大多数都独立于任何的容器。这些算法是通用的(**generic,或称泛型的**)：他们可用于**不同类型的容器**和**不同类型的元素**。
        * 标准库并未给每个容器都定义成员函数来实现这些操作，**而是定义了一组泛型算法(generic algorithm)**：**称它们为“算法”**，是因为它们实现了一些经典算法的公共接口，如排序搜索;**称它们是“泛型的”**，是因为它们可以用于不同类型的元素和多种容器类型(不仅包含标准库类型，如vector或list，还包括内置的数组类型)，以及我们将看到的，还能用于其他类型的序列。
        * 泛型算法本身不会执行容器的操作，它们只会运行在迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的变成假定：**算法永远不会改变容器底层的大小**。算法可能改变容器种保存的值，也可能容器内移动元素，但永远不会直接添加或删除元素。
        * 标准器算法从来**不直接操作容器**，它们只操作迭代器，从而**间接访问容器**。能不能插入和删除元素，不在于算法，而在于传递给他们的迭代器是否具有这样的功能。
        * 你认为标准库算法不改变容器大小的原因是什么？
            - 泛型算法的一大优点是“泛型”，也就是一个算法可以用于多种不同的数据类型，**算法与所操作的数据结构分离**。这对编程效率的提升是巨大的。
            - 要做到算法与数据结构分离，**重要的技术手段就是使用迭代器作为二者的桥梁**。算法从不操作具体的容器，从而也就不存在与特定的容器绑定，不适用于其他容器的问题。算法只操作迭代器，由迭代器真正实现对容器的访问。不同容器实现自己特定的迭代器(但不同迭代器是相容的)，算法操作不同迭代器就实现了对不同迭代器的访问。
            - 因此，并不是算法应该改变不应该改变容器的问题。为了实现算法于数据结构的分离，为了实现通用性，**算法根本就不该知道容器的存在。**算法访问数据的唯一通道是迭代器。是否改变容器的大小，完全是迭代器的责任。放我们向fill_n传递back_inserter时，虽然最终的效果是向容器添加了新的元素，但对fill_n来说，根本不知道这回事。它仍然像往常一样(通过迭代器)向容器赋予新值。只不过这次通过back_inserter来赋值，而back_inserter选择将新值添加到容器而已。
        * 我们使用的过的仅有的二种可调用对象**是函数和函数指针**。还有其他二种可调用对象：**重载了函数调用运算符的类**，以及*lambda表达式*。
        * 一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个表达式具有如下形式：
        *    [capture list] (parameter list) -> return type {function body}
        * 关联容器和顺序容器有着根本的不同：**关联容器中的元素**是按照**关键字保存和访问的**。与之相对，**顺序容器的元素**是按它们在**容器中的位置来顺序保存和访问的**。
        * 静态内存用来保存局部static对象、类static数据成员、和定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。
        * 程序使用动态内存出于以下三种原因之一
            - 程序不知道自己需要使用多少对象
            - 程序不知道自己所需对象的准确类型
            - 程序需要在多个对象间共享数据
        * 使用动态内存的一个常见原因就是允许多个对象共享相同的状态
        * 我们传递给delete的指针必须是指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。
        * 被内置指针管理的动态内存在被显示释放前一直都会存在
        * 使用内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。
        * 拷贝初始化不仅在我们使用=定义变量时会发生，在下列情况也会发生。
            - 将一个对象作为实参传递给一个非引用类型的形参
            - 从一个返回类型为非引用类型的函数返回一个对象
            - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
        * 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于其他任何函数也有一个函数返回类型和一个参数列表。
        * 构造函数初始化对象的非static数据成员，还可能做一些其他的工作。构造函数释放对象的资源，并销毁对象的非static数据成员。
        * 认识到析构函数本身并不直接销毁成员是非常重要的，成员是在析构函数体之后隐含的析构阶段中被销毁的。在析构函数中，首先执行函数体，然后再销毁成员，并且成员按照初始化的逆序进行销毁。
        * 有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。
        * 如果一个类需要一个析构函数，我们几乎可以肯定他也需要一个拷贝函数和一个拷贝赋值运算符。[C++之类的析构函数](https://www.cnblogs.com/MrListening/p/5567762.html)
        * 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。
        * 类的行为像一个值，意味着他应该有自己的状态。当我们拷贝一个像值得对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。
        * 行为像指针的类则共享状态。当我们拷贝一个这种状态类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。
        * 当一个类没有定义任何自己版本的拷贝控制成员，且他的数据成员都能移动构造或移动赋值时，编译器才会为他合成移动构造函数或移动赋值运算符。
        * 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则这些成员默认的被定义为是删除的。
        * 所有五个拷贝控制成员(拷贝构造函数、拷贝赋值运算符、析构函数、移动构造函数、移动赋值运算符)应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，他就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外的开销。在这种拷贝非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。
        * 分配了内存或其他资源的类几乎总是需要定义拷贝控制成员来管理分配的资源。如果一个类需要析构函数，则他几乎肯定也需要定义移动和拷贝构造函数及移动和拷贝赋值运算符。
        * 重载的运算符是具有特殊名字的函数：他的名字由关键字operator和其后定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。
        * 当一个重载运算符函数是成员函数时，this绑定到左侧运算对象。成员运算符函数的(显式)参数数量比运算对象的数量少一个。
        * 通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。
        * 如果某个类在逻辑上有相等的含义，则该类应该定义operator==,这样做可以使得用户更容易使用标准库算法来处理这个类。
        * 面向对象设计的核心思想是数据抽象、继承和多态。通过使用数据抽象，我们可以将类的接口和实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型区别，而以统一的方式使用它们的对象。
        * 在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时，将发生动态绑定。
        * 因为派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们能将基类的指针或引用绑定到派生类对象中的基类部分。
        * 尽管在派生类对象中含有从基类继承而来的成员，但派生类并不能直接初始化这些成员。和其他创建乐乐基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。
        * 每个类控制它自己的成员初始化过程。
        * 可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能时基类对象，也可能是派生类对象。
        * 和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我门可以将一个派生类对象的指针存储在一个基类的智能指针内。
        * 基类的指针或引用的静态类型可能与其动态类型不一致，读者一定要理解其中的原因。
        * 之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以邦定到基类部分。一个基类的对象即可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。
        * 因为一个基类的对象可能是派生类的一部分，也可能不是，所以不存在基类向派生类的自动类型转换。
        * 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有改派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略。
        * 从派生类向基类的类型转换只对指针或引用有效
        * 基类向派生类不存在隐式类型转换
        * 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而不得可行。
        * 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
        * 含有(或者未经覆盖直接继承)纯虚函数的类时抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖接口。我们不能直接创建一个抽象基类的对象。
        * 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。
        * 当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。
        * 函数模板和类模板成员函数的定义通常放在头文件中
        * 默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。
        * 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。
        * 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。
        * 在模板实参推断过程中，允许数组到指针的转换。但是，如果形参是一个引用，则数组不会转换为一个指针。
        * 如果一个函数参数是指向模板类型参数的右值引用(如T&&),它对应的实参的const属性和左值/右值属性将得到保持。
        * 函数模板可以被另一个模板或一个普通非模板函数重载
        * 标准库算法都是函数模板，标准库容器都是类模板。
        * 
- 4. python面试问题
    + [Python学习笔记——可变对象和不可变对象](https://blog.csdn.net/taohuaxinmu123/article/details/39008281)
    + [python 装饰器](https://www.cnblogs.com/lianyingteng/p/7743876.html)
    + [python中的函数式编程与装饰器](https://www.cnblogs.com/blackclody/p/6884036.html)
    + [Python中*args和**kwargs的区别](https://www.cnblogs.com/yunguoxiaoqiao/p/7626992.html)
    + python下划线
        * (1)、以单下划线开头，表示这是一个保护成员，只有类对象和子类对象自己能访问到这些变量。以单下划线开头的变量和函数被默认当作是内部函数，使用from module improt *时不会被获取，但是使用import module可以获取
        * (2)、以单下划线结尾仅仅是为了区别该名称与关键词
        * (3)、双下划线开头，表示为私有成员，只允许类本身访问，子类也不行。在文本上被替换为_class__method
        * (4)、双下划线开头，双下划线结尾。一种约定，Python内部的名字，用来区别其他用户自定义的命名,以防冲突。是一些 Python 的“魔术”对象，表示这是一个特殊成员，例如：定义类的时候，若是添加__init__方法，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初使化，Python不建议将自己命名的方法写为这种形式。
    + python垃圾回收机制
        * 总体来说，在Python中，主要通过**引用计数**进行垃圾回收；通过 **“标记-清除”** 解决容器对象可能产生的循环引用问题；通过 **“分代回收” **以**空间换时间**的方法提高垃圾回收效率。
        * [Python垃圾回收机制详解](https://www.cnblogs.com/xjng/p/5128269.html)
        * [Python垃圾回收机制详解](https://blog.csdn.net/xiongchengluo1129/article/details/80462651)
    + 可迭代对象，迭代器，生成器
        * [Python可迭代对象，迭代器，生成器的区别](https://blog.csdn.net/jinixin/article/details/72232604)
        * [可迭代对象、迭代器、生成器的理解](https://www.cnblogs.com/zhaof/p/7628049.html)
        * [python面试题（四）](https://juejin.im/post/5b5e6bb86fb9a04fd8357ff1)
        * [python 生成器和迭代器有这篇就够了](https://www.cnblogs.com/wj-1314/p/8490822.html)
    + [Python面试之 is 和 == 的区别](https://zhuanlan.zhihu.com/p/35219174)
    + [python 中 super函数的使用](https://www.cnblogs.com/silencestorm/p/8404046.html)
    + [Python中range和xrange的区别](https://www.cnblogs.com/wangxue533/p/10581125.html)
    + [Lambda 表达式有何用处？如何使用？](https://www.zhihu.com/question/20125256)
    + [谈谈自己的理解:python中闭包，闭包的实质](https://www.cnblogs.com/s-1314-521/p/9763376.html)
    + [Python 最难的问题-协程](https://www.oschina.net/translate/pythons-hardest-problem)
    + [Python中的 _init__和 _new__的区别](https://www.cnblogs.com/xiaozao/p/9598946.html)
    + 
- 数据库
    + [数据库中的union与union all的区别](https://www.cnblogs.com/klb561/p/11391052.html)
    + [SQL语句中----删除表数据drop、truncate和delete的用法](https://www.cnblogs.com/fjl0418/p/7929420.html)
    + [SQL语句增加列、修改列、删除列 ](https://www.cnblogs.com/shiyh/p/10362505.html)
    + [关系型数据库与非关系型数据库的对比分析（优缺点，应用，区别等）](https://blog.csdn.net/qq_33472765/article/details/81515251)
    + [查找某个字段最大值的记录 MS SQL](https://www.cnblogs.com/platero/archive/2010/08/18/1870153.html)
    + [MySQL学习笔记：like和regexp的区别](https://www.cnblogs.com/hider/p/9121704.html)
    + [关于数据库优化1——关于count(1)，count(*),和count(列名)的区别，和关于表中字段顺序的问题](https://www.cnblogs.com/Caucasian/p/7041061.html)